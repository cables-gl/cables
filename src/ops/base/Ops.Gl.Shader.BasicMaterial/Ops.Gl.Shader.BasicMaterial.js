const render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    shaderOut = op.outObject("shader");

shaderOut.ignoreValueSerialize = true;
const cgl = op.patch.cgl;

let shader = new CGL.Shader(cgl, "BasicMaterial");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.bindTextures = bindTextures;
shader.setSource(attachments.shader_vert, attachments.shader_frag);
shaderOut.setRef(shader);

render.onTriggered = doRender;

let textureOpacity = null;
let textureOpacityUniform = null;

function bindTextures()
{
    if (diffuseTexture.get()) cgl.setTexture(0, diffuseTexture.get().tex);
    if (textureOpacity.get()) cgl.setTexture(1, textureOpacity.get().tex);
}

op.preRender = function ()
{
    shader.bind();
    doRender();
};

function doRender()
{
    if (!shader) return;

    cgl.pushShader(shader);
    shader.bindTextures();

    trigger.trigger();

    cgl.popShader();
}

{
    // rgba colors
    const r = op.inValueSlider("r", Math.random()),
        g = op.inValueSlider("g", Math.random()),
        b = op.inValueSlider("b", Math.random()),
        a = op.inValueSlider("a", 1.0);
    r.setUiAttribs({ "colorPick": true });

    a.uniform = new CGL.Uniform(shader, "f", "a", a);
    b.uniform = new CGL.Uniform(shader, "f", "b", b);
    r.uniform = new CGL.Uniform(shader, "f", "r", r);
    g.uniform = new CGL.Uniform(shader, "f", "g", g);

    op.setPortGroup("Color", [r, g, b, a]);

}

{
    // diffuse outTexture

    var diffuseTexture = op.inTexture("texture");
    let diffuseTextureUniform = null;
    shader.bindTextures = bindTextures;

    diffuseTexture.onChange = function ()
    {
        if (diffuseTexture.get())
        {
            // if(diffuseTextureUniform!==null)return;
            // shader.addveUniform('texDiffuse');
            if (!shader.hasDefine("HAS_TEXTURE_DIFFUSE"))shader.define("HAS_TEXTURE_DIFFUSE");
            if (!diffuseTextureUniform)diffuseTextureUniform = new CGL.Uniform(shader, "t", "texDiffuse", 0);
            updateTexRepeat();
        }
        else
        {
            shader.removeUniform("texDiffuse");
            shader.removeDefine("HAS_TEXTURE_DIFFUSE");
            diffuseTextureUniform = null;
        }
    };
}

{
    // opacity texture
    textureOpacity = op.inTexture("textureOpacity");

    textureOpacity.onChange = function ()
    {
        if (textureOpacity.get())
        {
            if (textureOpacityUniform !== null) return;
            shader.removeUniform("texOpacity");
            shader.define("HAS_TEXTURE_OPACITY");
            if (!textureOpacityUniform)textureOpacityUniform = new CGL.Uniform(shader, "t", "texOpacity", 1);
        }
        else
        {
            shader.removeUniform("texOpacity");
            shader.removeDefine("HAS_TEXTURE_OPACITY");
            textureOpacityUniform = null;
        }
    };

}

op.colorizeTexture = op.inValueBool("colorizeTexture");
op.colorizeTexture.set(false);
op.colorizeTexture.onChange = function ()
{
    if (op.colorizeTexture.get()) shader.define("COLORIZE_TEXTURE");
    else shader.removeDefine("COLORIZE_TEXTURE");
};

op.doBillboard = op.inValueBool("billboard");
op.doBillboard.set(false);

op.doBillboard.onChange = function ()
{
    if (op.doBillboard.get()) shader.define("BILLBOARD");
    else shader.removeDefine("BILLBOARD");
};

let texCoordAlpha = op.inValueBool("Opacity TexCoords Transform", false);

texCoordAlpha.onChange = function ()
{
    if (texCoordAlpha.get()) shader.define("TRANSFORMALPHATEXCOORDS");
    else shader.removeDefine("TRANSFORMALPHATEXCOORDS");

};

let preMultipliedAlpha = op.inValueBool("preMultiplied alpha");

function updateTexRepeat()
{
    if (!diffuseRepeatXUniform)
    {
        diffuseRepeatXUniform = new CGL.Uniform(shader, "f", "diffuseRepeatX", diffuseRepeatX);
        diffuseRepeatYUniform = new CGL.Uniform(shader, "f", "diffuseRepeatY", diffuseRepeatY);
        diffuseOffsetXUniform = new CGL.Uniform(shader, "f", "texOffsetX", diffuseOffsetX);
        diffuseOffsetYUniform = new CGL.Uniform(shader, "f", "texOffsetY", diffuseOffsetY);
    }

    diffuseRepeatXUniform.setValue(diffuseRepeatX.get());
    diffuseRepeatYUniform.setValue(diffuseRepeatY.get());
    diffuseOffsetXUniform.setValue(diffuseOffsetX.get());
    diffuseOffsetYUniform.setValue(diffuseOffsetY.get());
}

{
    // texture coords

    var diffuseRepeatX = op.inValueFloat("diffuseRepeatX", 1);
    var diffuseRepeatY = op.inValueFloat("diffuseRepeatY", 1);
    var diffuseOffsetX = op.inValueFloat("Tex Offset X");
    var diffuseOffsetY = op.inValueFloat("Tex Offset Y");

    op.setPortGroup("Transform Texture", [diffuseRepeatX, diffuseRepeatY, diffuseOffsetX, diffuseOffsetY]);

    diffuseRepeatX.onChange = updateTexRepeat;
    diffuseRepeatY.onChange = updateTexRepeat;
    diffuseOffsetY.onChange = updateTexRepeat;
    diffuseOffsetX.onChange = updateTexRepeat;

    var diffuseRepeatXUniform = null;
    var diffuseRepeatYUniform = null;
    var diffuseOffsetXUniform = null;
    var diffuseOffsetYUniform = null;

    shader.define("TEXTURE_REPEAT");

    diffuseOffsetX.set(0);
    diffuseOffsetY.set(0);
    diffuseRepeatX.set(1);
    diffuseRepeatY.set(1);
}

updateTexRepeat();
